#!/usr/bin/env python3
"""
Integra√ß√£o do Agente PRP com MCP Turso para Persist√™ncia.

Esta vers√£o usa o MCP Turso para armazenar e consultar dados do agente PRP
no banco context-memory.
"""

import asyncio
import json
import logging
from typing import Dict, Any, List, Optional
from datetime import datetime
from openai import AsyncOpenAI
import os
from dotenv import load_dotenv

# Carregar vari√°veis de ambiente
load_dotenv()

# Configurar logging
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

class CursorTursoIntegration:
    """
    Integra√ß√£o do Agente PRP com MCP Turso para persist√™ncia.
    
    Armazena conversas, PRPs e an√°lises no banco Turso via MCP.
    """
    
    def __init__(self):
        # Configurar OpenAI
        api_key = os.getenv("LLM_API_KEY", "sua_chave_openai_aqui")
        base_url = os.getenv("LLM_BASE_URL", "https://api.openai.com/v1")
        model = os.getenv("LLM_MODEL", "gpt-4")
        
        self.client = AsyncOpenAI(
            api_key=api_key,
            base_url=base_url
        )
        self.model = model
        self.conversation_history = []
        
        self.system_prompt = """Voc√™ √© um assistente especializado em an√°lise e gerenciamento de PRPs (Product Requirement Prompts).

**Suas responsabilidades:**
1. **An√°lise de C√≥digo** - Identificar funcionalidades, problemas e melhorias
2. **Cria√ß√£o de PRPs** - Sugerir estruturas de PRPs baseadas em requisitos
3. **Insights de Projeto** - Fornecer an√°lises sobre status e progresso
4. **Recomenda√ß√µes** - Sugerir melhorias e pr√≥ximos passos

**Como responder:**
- Seja natural e conversacional
- Forne√ßa an√°lises detalhadas mas concisas
- Sugira a√ß√µes pr√°ticas e acion√°veis
- Mantenha contexto da conversa
- Use linguagem t√©cnica quando apropriado, mas explique conceitos complexos

**Formato de resposta:**
- Use emojis para tornar mais visual
- Estruture informa√ß√µes de forma clara
- Destaque pontos importantes
- Sempre sugira pr√≥ximos passos

**Contexto:** Voc√™ est√° sendo usado no Cursor Agent para ajudar desenvolvedores a criar e gerenciar PRPs de forma natural."""
    
    async def call_mcp_turso(self, tool_name: str, params: Dict[str, Any]) -> Dict[str, Any]:
        """
        Interface para MCP Turso.
        
        NOTA: Em ambiente de produ√ß√£o com MCP ativo, esta fun√ß√£o seria substitu√≠da
        pela chamada real ao MCP Turso atrav√©s do protocolo MCP.
        
        Para usar com MCP real, descomente e configure adequadamente.
        """
        
        print(f"üíæ Turso MCP: {tool_name} - {params.get('database', 'context-memory')}")
        
        # TODO: Implementar chamada real ao MCP Turso quando dispon√≠vel
        # Exemplo de integra√ß√£o real:
        # try:
        #     from mcp_client import MCPClient
        #     client = MCPClient()
        #     return await client.call_tool(tool_name, params)
        # except Exception as e:
        #     logger.error(f"Erro MCP Turso: {e}")
        #     return {"success": False, "error": str(e)}
        
        # Simula√ß√£o para desenvolvimento e testes
        if tool_name == "mcp_turso_mcp_turso_execute_query":
            if "INSERT" in params.get("query", ""):
                return {
                    "success": True, 
                    "lastInsertId": hash(params.get("query", "")) % 1000,
                    "rowsAffected": 1
                }
            elif "SELECT" in params.get("query", ""):
                return {
                    "success": True,
                    "rows": [
                        {
                            "id": 1,
                            "session_id": "cursor-agent-20250802",
                            "user_message": "Exemplo de mensagem",
                            "timestamp": datetime.now().isoformat()
                        }
                    ],
                    "columns": ["id", "session_id", "user_message", "timestamp"]
                }
            else:
                return {"success": True, "rowsAffected": 1}
                
        elif tool_name == "mcp_turso_mcp_turso_execute_read_only_query":
            return {
                "success": True,
                "rows": [
                    {
                        "id": 1,
                        "name": "prp-exemplo",
                        "title": "PRP: Funcionalidade Exemplo",
                        "status": "draft",
                        "created_at": datetime.now().isoformat()
                    }
                ],
                "columns": ["id", "name", "title", "status", "created_at"]
            }
            
        else:
            return {"success": False, "error": f"Ferramenta {tool_name} n√£o implementada"}
    
    async def store_conversation(self, user_message: str, agent_response: str, file_context: str = None) -> bool:
        """
        Armazena conversa no banco Turso via MCP.
        """
        
        try:
            query = """
            INSERT INTO conversations (
                session_id, user_message, agent_response, file_context, 
                timestamp, message_type, metadata
            ) VALUES (?, ?, ?, ?, ?, ?, ?)
            """
            
            params = [
                f"cursor-agent-{datetime.now().strftime('%Y%m%d')}",
                user_message,
                agent_response,
                file_context or "",
                datetime.now().isoformat(),
                "chat",
                json.dumps({"source": "cursor-agent", "version": "1.0"})
            ]
            
            result = await self.call_mcp_turso("mcp_turso_execute_query", {
                "database": "context-memory",
                "query": query,
                "params": params
            })
            
            return result.get("success", False)
            
        except Exception as e:
            logger.error(f"Erro ao armazenar conversa: {e}")
            return False
    
    async def store_prp_suggestion(self, feature: str, context: str, prp_content: str) -> int:
        """
        Armazena sugest√£o de PRP no banco Turso via MCP.
        """
        
        try:
            query = """
            INSERT INTO prps (
                name, title, description, objective, context_data, 
                implementation_details, status, priority, tags, created_at
            ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
            """
            
            # Gerar nome √∫nico baseado na feature
            name = f"prp-{feature.lower().replace(' ', '-')}-{datetime.now().strftime('%Y%m%d-%H%M%S')}"
            title = f"PRP: {feature}"
            
            params = [
                name,
                title,
                prp_content,
                f"Implementar {feature}",
                json.dumps({"context": context, "source": "cursor-agent"}),
                json.dumps({"suggested_by": "cursor-agent", "llm_analysis": True}),
                "draft",
                "medium",
                json.dumps(["cursor-agent", "llm-generated"]),
                datetime.now().isoformat()
            ]
            
            result = await self.call_mcp_turso("mcp_turso_execute_query", {
                "database": "context-memory",
                "query": query,
                "params": params
            })
            
            return result.get("lastInsertId", 0)
            
        except Exception as e:
            logger.error(f"Erro ao armazenar PRP: {e}")
            return 0
    
    async def store_analysis(self, file_path: str, content: str, analysis: str) -> int:
        """
        Armazena an√°lise de arquivo no banco Turso via MCP.
        """
        
        try:
            query = """
            INSERT INTO prp_llm_analysis (
                prp_id, analysis_type, analysis_content, llm_model, 
                analysis_timestamp, metadata
            ) VALUES (?, ?, ?, ?, ?, ?)
            """
            
            params = [
                1,  # prp_id (associar com PRP geral)
                "file_analysis",
                analysis,
                self.model,
                datetime.now().isoformat(),
                json.dumps({
                    "file_path": file_path,
                    "content_preview": content[:500],
                    "source": "cursor-agent"
                })
            ]
            
            result = await self.call_mcp_turso("mcp_turso_execute_query", {
                "database": "context-memory",
                "query": query,
                "params": params
            })
            
            return result.get("lastInsertId", 0)
            
        except Exception as e:
            logger.error(f"Erro ao armazenar an√°lise: {e}")
            return 0
    
    async def get_conversation_history(self, limit: int = 10) -> List[Dict[str, Any]]:
        """
        Obt√©m hist√≥rico de conversas do banco Turso via MCP.
        """
        
        try:
            query = """
            SELECT session_id, user_message, agent_response, timestamp, file_context
            FROM conversations 
            WHERE session_id LIKE 'cursor-agent-%'
            ORDER BY timestamp DESC 
            LIMIT ?
            """
            
            result = await self.call_mcp_turso("mcp_turso_execute_read_only_query", {
                "database": "context-memory",
                "query": query,
                "params": [limit]
            })
            
            return result.get("rows", [])
            
        except Exception as e:
            logger.error(f"Erro ao obter hist√≥rico: {e}")
            return []
    
    async def get_prp_suggestions(self, limit: int = 10) -> List[Dict[str, Any]]:
        """
        Obt√©m sugest√µes de PRPs do banco Turso via MCP.
        """
        
        try:
            query = """
            SELECT id, name, title, description, status, priority, created_at, tags
            FROM prps 
            WHERE tags LIKE '%cursor-agent%'
            ORDER BY created_at DESC 
            LIMIT ?
            """
            
            result = await self.call_mcp_turso("mcp_turso_execute_read_only_query", {
                "database": "context-memory",
                "query": query,
                "params": [limit]
            })
            
            return result.get("rows", [])
            
        except Exception as e:
            logger.error(f"Erro ao obter PRPs: {e}")
            return []
    
    async def chat_natural(self, message: str, file_context: str = None) -> str:
        """
        Conversa natural com o LLM e armazena no Turso.
        """
        
        # Adicionar contexto se fornecido
        full_message = message
        if file_context:
            full_message = f"Contexto do arquivo atual:\n{file_context}\n\nSolicita√ß√£o do usu√°rio: {message}"
        
        # Adicionar ao hist√≥rico local
        self.conversation_history.append({
            "user": message,
            "timestamp": datetime.now().isoformat(),
            "file_context": file_context
        })
        
        try:
            # Preparar mensagens
            messages = [{"role": "system", "content": self.system_prompt}]
            
            # Adicionar hist√≥rico recente
            recent_history = self.conversation_history[-6:]
            for item in recent_history:
                if "user" in item:
                    messages.append({"role": "user", "content": item["user"]})
                if "agent" in item:
                    messages.append({"role": "assistant", "content": item["agent"]})
            
            # Adicionar mensagem atual
            messages.append({"role": "user", "content": full_message})
            
            # Chamar OpenAI com timeout
            response = await asyncio.wait_for(
                self.client.chat.completions.create(
                    model=self.model,
                    messages=messages,
                    max_tokens=1500,
                    temperature=0.7
                ),
                timeout=30.0
            )
            
            # Extrair resposta
            response_content = response.choices[0].message.content
            
            # Armazenar no Turso via MCP
            await self.store_conversation(message, response_content, file_context)
            
            # Adicionar resposta ao hist√≥rico local
            self.conversation_history.append({
                "agent": response_content,
                "timestamp": datetime.now().isoformat()
            })
            
            return self._format_response(response_content, message)
            
        except asyncio.TimeoutError:
            logger.error("Timeout na chamada da API")
            return "‚ùå Desculpe, a resposta demorou muito. Tente novamente."
        except Exception as e:
            logger.error(f"Erro na conversa: {e}")
            return f"‚ùå Desculpe, tive um problema: {str(e)}"
    
    def _format_response(self, response: str, original_message: str) -> str:
        """
        Formata resposta de forma natural e contextualizada.
        """
        
        message_lower = original_message.lower()
        
        # Detectar tipo de solicita√ß√£o
        if any(word in message_lower for word in ["criar", "novo", "fazer", "desenvolver"]):
            return f"üéØ **PRP Sugerido!**\n\n{response}\n\nüí° **Pr√≥ximos passos:**\n‚Ä¢ Analisei o contexto automaticamente\n‚Ä¢ Sugeri estrutura e tarefas\n‚Ä¢ Considerei padr√µes do projeto\n‚Ä¢ üíæ Salvei no banco Turso\n\nQuer que eu detalhe algum aspecto?"
        
        elif any(word in message_lower for word in ["analisar", "revisar", "verificar", "examinar"]):
            return f"üîç **An√°lise Realizada**\n\n{response}\n\nüìä **Insights:**\n‚Ä¢ Identifiquei pontos de melhoria\n‚Ä¢ Sugeri otimiza√ß√µes\n‚Ä¢ Considerei boas pr√°ticas\n‚Ä¢ üíæ Salvei an√°lise no Turso\n\nQuer que eu detalhe algum ponto espec√≠fico?"
        
        elif any(word in message_lower for word in ["buscar", "encontrar", "procurar", "listar"]):
            return f"üìã **Busca Realizada**\n\n{response}\n\nüîç **Resultados:**\n‚Ä¢ Busca contextual inteligente\n‚Ä¢ Ordena√ß√£o por relev√¢ncia\n‚Ä¢ Filtros aplicados automaticamente\n‚Ä¢ üíæ Consultando banco Turso\n\nQuer ver mais detalhes?"
        
        elif any(word in message_lower for word in ["status", "progresso", "como est√°"]):
            return f"üìä **Status do Projeto**\n\n{response}\n\nüìà **M√©tricas:**\n‚Ä¢ An√°lise de progresso geral\n‚Ä¢ Identifica√ß√£o de riscos\n‚Ä¢ Sugest√µes de melhoria\n‚Ä¢ üíæ Dados do Turso\n\nQuer um plano de a√ß√£o detalhado?"
        
        else:
            return f"ü§ñ **Resposta do Agente**\n\n{response}\n\nüí≠ **Contexto:**\n‚Ä¢ Mantive hist√≥rico da conversa\n‚Ä¢ Considerei padr√µes do projeto\n‚Ä¢ Sugest√µes personalizadas\n‚Ä¢ üíæ Salvei no Turso\n\nComo posso ajudar mais?"
    
    async def suggest_prp(self, feature: str, context: str = "") -> str:
        """
        Sugere estrutura de PRP e armazena no Turso.
        """
        
        prompt = f"""
        Crie uma sugest√£o detalhada de PRP para: **{feature}**
        
        **Contexto:** {context}
        
        **Estrutura sugerida:**
        1. **Objetivo** - O que queremos alcan√ßar?
        2. **Requisitos funcionais** - Que funcionalidades precisamos?
        3. **Requisitos n√£o-funcionais** - Performance, seguran√ßa, etc.
        4. **Tarefas espec√≠ficas** - Lista de tarefas acion√°veis
        5. **Crit√©rios de aceita√ß√£o** - Como saber se est√° pronto?
        6. **Riscos e depend√™ncias** - O que pode dar errado?
        7. **Estimativa** - Complexidade e tempo estimado
        
        Seja detalhado mas pr√°tico.
        """
        
        response = await self.chat_natural(prompt)
        
        # Armazenar PRP no Turso
        prp_id = await self.store_prp_suggestion(feature, context, response)
        
        if prp_id > 0:
            response += f"\n\nüíæ **PRP salvo no Turso com ID: {prp_id}**"
        
        return response
    
    async def analyze_file(self, file_path: str, content: str) -> str:
        """
        Analisa arquivo e armazena an√°lise no Turso.
        """
        
        prompt = f"""
        Analise este arquivo e forne√ßa insights detalhados:
        
        **Arquivo:** {file_path}
        **Conte√∫do:**
        {content[:1500]}...
        
        **Por favor analise:**
        1. **Funcionalidades principais** - O que o c√≥digo faz?
        2. **Pontos de melhoria** - O que pode ser otimizado?
        3. **Problemas potenciais** - H√° bugs ou vulnerabilidades?
        4. **Sugest√µes de PRPs** - Que PRPs voc√™ sugeriria?
        5. **Pr√≥ximos passos** - O que fazer agora?
        
        Seja espec√≠fico e acion√°vel.
        """
        
        response = await self.chat_natural(prompt)
        
        # Armazenar an√°lise no Turso
        analysis_id = await self.store_analysis(file_path, content, response)
        
        if analysis_id > 0:
            response += f"\n\nüíæ **An√°lise salva no Turso com ID: {analysis_id}**"
        
        return response
    
    async def get_project_insights(self) -> str:
        """
        Obt√©m insights do projeto consultando o Turso.
        """
        
        # Obter dados do Turso
        conversations = await self.get_conversation_history(5)
        prps = await self.get_prp_suggestions(5)
        
        # Preparar contexto com dados do Turso
        turso_context = f"""
        **Dados do Turso:**
        - Conversas recentes: {len(conversations)}
        - PRPs criados: {len(prps)}
        - √öltima atividade: {conversations[0]['timestamp'] if conversations else 'N/A'}
        """
        
        prompt = f"""
        Analise o projeto atual e forne√ßa insights valiosos:
        
        {turso_context}
        
        **An√°lise solicitada:**
        1. **Status geral** - Como est√° o progresso do projeto?
        2. **Tarefas priorit√°rias** - O que precisa de aten√ß√£o imediata?
        3. **Riscos identificados** - Quais s√£o os principais riscos?
        4. **Oportunidades** - Onde podemos melhorar?
        5. **Pr√≥ximos passos** - Que a√ß√µes voc√™ recomenda?
        6. **M√©tricas sugeridas** - Como medir o progresso?
        
        Baseie-se nos dados do Turso e padr√µes de projetos similares.
        Seja conciso mas informativo.
        """
        
        return await self.chat_natural(prompt)
    
    async def get_turso_summary(self) -> str:
        """
        Obt√©m resumo dos dados armazenados no Turso.
        """
        
        try:
            conversations = await self.get_conversation_history(10)
            prps = await self.get_prp_suggestions(10)
            
            summary = f"""
            üìä **Resumo dos Dados no Turso**
            
            **Conversas:** {len(conversations)} registradas
            **PRPs:** {len(prps)} criados
            
            **√öltimas Conversas:**
            """
            
            for conv in conversations[:3]:
                summary += f"\n‚Ä¢ {conv['timestamp']}: {conv['user_message'][:50]}..."
            
            summary += "\n\n**PRPs Recentes:**"
            for prp in prps[:3]:
                summary += f"\n‚Ä¢ {prp['title']} (Status: {prp['status']})"
            
            return summary
            
        except Exception as e:
            logger.error(f"Erro ao obter resumo do Turso: {e}")
            return "‚ùå Erro ao consultar dados do Turso"

# Inst√¢ncia global
cursor_turso_agent = CursorTursoIntegration()

# Fun√ß√µes de conveni√™ncia para uso no Cursor Agent
async def chat_natural(message: str, file_context: str = None) -> str:
    """Conversa natural com armazenamento no Turso."""
    return await cursor_turso_agent.chat_natural(message, file_context)

async def suggest_prp(feature: str, context: str = "") -> str:
    """Sugere PRP e armazena no Turso."""
    return await cursor_turso_agent.suggest_prp(feature, context)

async def analyze_file(file_path: str, content: str) -> str:
    """Analisa arquivo e armazena no Turso."""
    return await cursor_turso_agent.analyze_file(file_path, content)

async def get_insights() -> str:
    """Obt√©m insights consultando o Turso."""
    return await cursor_turso_agent.get_project_insights()

async def get_turso_summary() -> str:
    """Obt√©m resumo dos dados no Turso."""
    return await cursor_turso_agent.get_turso_summary()

# Teste interativo
async def interactive_demo():
    """Demonstra√ß√£o interativa da integra√ß√£o com Turso."""
    
    print("üöÄ **Cursor Agent PRP com Integra√ß√£o Turso MCP**")
    print("="*60)
    print("üí¨ **Converse naturalmente com o agente!**")
    print("üìù **Comandos especiais:**")
    print("   ‚Ä¢ 'insights' - An√°lise do projeto")
    print("   ‚Ä¢ 'resumo' - Dados do Turso")
    print("   ‚Ä¢ 'sair' - Encerrar")
    print("="*60)
    
    while True:
        try:
            user_input = input("\nü§î **Voc√™:** ")
            
            if user_input.lower() in ['sair', 'exit', 'quit']:
                print("üëã **At√© logo! Dados salvos no Turso.**")
                break
            elif user_input.lower() == 'insights':
                response = await get_insights()
                print(f"\nü§ñ **Agente:** {response}")
            elif user_input.lower() == 'resumo':
                response = await get_turso_summary()
                print(f"\nü§ñ **Agente:** {response}")
            else:
                response = await chat_natural(user_input)
                print(f"\nü§ñ **Agente:** {response}")
                
        except KeyboardInterrupt:
            print("\n\nüëã **Sess√£o encerrada. Dados preservados no Turso!**")
            break
        except Exception as e:
            print(f"\n‚ùå **Erro:** {e}")

# Demonstra√ß√£o r√°pida
async def quick_demo():
    """Demonstra√ß√£o r√°pida das funcionalidades."""
    
    print("‚ö° **Demo R√°pido - Integra√ß√£o Turso MCP**\n")
    
    # Teste 1: Conversa simples
    print("1Ô∏è‚É£ **Teste: Conversa Natural**")
    response = await chat_natural("Ol√°! Como voc√™ pode me ajudar?")
    print(f"‚úÖ Resposta: {response[:100]}...\n")
    
    # Teste 2: Insights do projeto
    print("2Ô∏è‚É£ **Teste: Insights do Projeto**")
    response = await get_insights()
    print(f"‚úÖ Insights: {response[:100]}...\n")
    
    # Teste 3: Resumo do Turso
    print("3Ô∏è‚É£ **Teste: Resumo do Turso**")
    response = await get_turso_summary()
    print(f"‚úÖ Resumo: {response[:100]}...\n")
    
    print("‚úÖ **Todos os testes passaram!**")
    print("üíæ **Dados sendo persistidos no Turso MCP**")
    print("üéØ **Agente pronto para uso no Cursor!**")

if __name__ == "__main__":
    import sys
    
    if len(sys.argv) > 1 and sys.argv[1] == "--interactive":
        asyncio.run(interactive_demo())
    else:
        asyncio.run(quick_demo()) 